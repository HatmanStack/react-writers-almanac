# Phase 2: Test Coverage Analysis & Improvement

## Phase Goal

Strengthen the testing foundation by performing comprehensive coverage analysis, identifying under-tested code paths, and systematically adding unit tests to achieve 85%+ coverage across the codebase. This phase uses data-driven decision making (coverage reports) to focus testing effort on high-impact areas, ensuring new features and fixes are built on a well-tested foundation.

**Success Criteria**:
- ✅ Coverage report generated with detailed metrics
- ✅ Under-tested files identified (<70% coverage)
- ✅ Unit tests added to bring coverage to 85%+
- ✅ All new tests pass consistently
- ✅ No regressions in existing tests
- ✅ Coverage enforcement configured (optional stretch goal)

**Estimated tokens**: ~65,000

---

## Prerequisites

### Phase Dependencies
- [ ] Phase 1 complete (SAM deployment working)
- [ ] All existing tests passing: `npm test && npm run test:e2e`
- [ ] Clean working directory: `git status`

### Tools Verified
- [ ] Vitest installed and working: `npm test`
- [ ] Coverage tool installed: `@vitest/coverage-v8` in package.json
- [ ] Browser available to view HTML reports

### Understanding
- [ ] Read Phase 0 testing patterns and conventions
- [ ] Review existing test files for patterns
- [ ] Understand Arrange-Act-Assert pattern
- [ ] Familiar with Vitest and Testing Library APIs

---

## Tasks

### Task 1: Generate Baseline Coverage Report

**Goal**: Run comprehensive coverage analysis to establish baseline metrics and identify specific files and code paths that lack test coverage.

**Files to Create**:
- `coverage/` directory (generated by Vitest)
- `docs/coverage-baseline.md` - Document baseline metrics

**Prerequisites**:
- All tests currently passing
- Vitest coverage package installed

**Implementation Steps**:

1. **Run coverage analysis**:
   - Execute `npm run test:coverage`
   - Wait for all tests to complete
   - Note total coverage percentages (statements, branches, functions, lines)
   - Coverage report generates in `coverage/` directory

2. **Open HTML coverage report**:
   - Open `coverage/index.html` in browser
   - Browse file-by-file coverage details
   - Identify red (uncovered) and yellow (partially covered) sections
   - Note which files have <70% coverage

3. **Analyze coverage by category**:
   - Components coverage (src/components/**)
   - Hooks coverage (src/hooks/**)
   - Store coverage (src/store/**)
   - Utils coverage (src/utils/**)
   - API coverage (src/api/**)
   - Identify categories below target

4. **Document baseline metrics**:
   - Create `docs/coverage-baseline.md`
   - Record overall coverage percentages
   - List files with <70% coverage
   - Note specific uncovered lines/branches
   - Prioritize by criticality (core features > edge cases)

5. **Identify quick wins**:
   - Find files close to 70% (60-69%) - small effort for big impact
   - Find completely untested files (0-20%) - need comprehensive tests
   - Find files with uncovered error paths - critical for robustness

**Coverage Analysis Pattern**:
```bash
# Generate coverage
npm run test:coverage

# Output shows:
# File           | % Stmts | % Branch | % Funcs | % Lines
# Component.tsx  |   65.12 |    50.00 |   70.00 |   64.29

# Red flags:
# - % Branch < 50 (missing if/else paths)
# - % Lines < 70 (insufficient test coverage)
# - Critical files (App.tsx, store, API) < 80
```

**Verification Checklist**:
- [ ] Coverage report generated successfully
- [ ] HTML report opens in browser
- [ ] Overall coverage percentage documented
- [ ] Files with <70% coverage listed
- [ ] Baseline documented in docs/coverage-baseline.md
- [ ] Prioritized list of files to test created
- [ ] No test failures when running coverage

**Testing Instructions**:
```bash
# Run coverage
npm run test:coverage

# Expected output includes summary table:
# --------------------------------|---------|----------|---------|---------|
# File                            | % Stmts | % Branch | % Funcs | % Lines |
# --------------------------------|---------|----------|---------|---------|
# All files                       |   XX.XX |    XX.XX |   XX.XX |   XX.XX |

# Open HTML report
open coverage/index.html

# Look for:
# - Red highlighting = completely untested code
# - Yellow highlighting = partially covered code
# - Green highlighting = fully tested code

# Focus on files with:
# - <70% line coverage
# - <50% branch coverage
# - 0% function coverage
```

**Baseline Documentation Template**:
```markdown
# Test Coverage Baseline

**Date**: [Current date]
**Branch**: claude/design-new-feature-01SJt8Xs8ZfG9foLfshCCGsK

## Overall Metrics
- Statements: XX.XX%
- Branches: XX.XX%
- Functions: XX.XX%
- Lines: XX.XX%

## Files with <70% Coverage

### Critical (Core functionality)
- `src/App.tsx`: XX.XX% - Main application logic
- `src/api/client.ts`: XX.XX% - HTTP client

### High Priority (User-facing features)
- `src/components/PoemDates/PoemDates.tsx`: XX.XX%
- `src/components/Modal/Modal.tsx`: XX.XX%

### Medium Priority (Support utilities)
- `src/utils/performance.ts`: XX.XX%

## Specific Gaps Identified
- Error handling paths in API client
- Edge cases in date formatting
- Null/undefined handling in components

## Target
- Overall: 85%+ all metrics
- Critical files: 90%+
- Components: 90%+
- Utils: 100%
```

**Commit Message Template**:
```
test(coverage): generate baseline coverage report

- Run npm run test:coverage for baseline metrics
- Document overall coverage percentages
- Identify files with <70% coverage
- Prioritize testing targets by criticality
- Create docs/coverage-baseline.md
```

**Estimated tokens**: ~8,000

---

### Task 2: Add Tests for Under-Tested Components

**Goal**: Write comprehensive unit tests for React components identified as having <70% coverage, focusing on rendering, user interactions, and edge cases.

**Files to Create/Modify**:
- New test files for untested components (e.g., `Modal.test.tsx`, `PoemDates.test.tsx`)
- Modified test files to increase coverage

**Prerequisites**:
- Task 1 complete (coverage baseline established)
- List of under-tested components identified
- Understanding of existing component test patterns

**Implementation Steps**:

1. **Prioritize components to test**:
   - Review coverage report for components with <70%
   - Start with critical user-facing components
   - Then test shared/reusable components
   - Finally test edge case/rarely used components

2. **For each under-tested component**:
   - Read component source code to understand behavior
   - Identify props, state, and side effects
   - List test scenarios: happy path, error states, edge cases
   - Check existing tests to avoid duplication
   - Follow Arrange-Act-Assert pattern

3. **Write tests following project patterns**:
   - Use `describe` blocks to group related tests
   - Use `it` for individual test cases
   - Mock external dependencies (API, stores, hooks)
   - Test user-visible behavior, not implementation
   - Use `screen` queries from Testing Library
   - Prefer `getByRole` over `getByTestId` for accessibility

4. **Test component rendering**:
   - Test with different prop combinations
   - Test conditional rendering (if/else branches)
   - Test null/undefined prop handling
   - Test loading states
   - Test error states

5. **Test user interactions**:
   - Test button clicks
   - Test form inputs
   - Test keyboard navigation
   - Test focus management
   - Use `userEvent` for realistic interactions

6. **Run coverage after each file**:
   - Execute `npm run test:coverage`
   - Verify coverage increased for target file
   - Aim for 90%+ coverage per file
   - Re-run if coverage didn't improve

**Component Testing Pattern**:
```typescript
// ComponentName.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  describe('rendering', () => {
    it('should render with required props', () => {
      render(<ComponentName prop1="value1" />);
      expect(screen.getByRole('...')).toBeInTheDocument();
    });

    it('should not render when condition is false', () => {
      render(<ComponentName show={false} />);
      expect(screen.queryByRole('...')).not.toBeInTheDocument();
    });
  });

  describe('user interactions', () => {
    it('should call onClick when button clicked', async () => {
      const handleClick = vi.fn();
      render(<ComponentName onClick={handleClick} />);

      await userEvent.click(screen.getByRole('button'));

      expect(handleClick).toHaveBeenCalledTimes(1);
    });
  });

  describe('edge cases', () => {
    it('should handle null props gracefully', () => {
      render(<ComponentName data={null} />);
      expect(screen.getByText('No data')).toBeInTheDocument();
    });
  });
});
```

**Verification Checklist**:
- [ ] Test files created for all under-tested components
- [ ] Each test file has describe blocks grouping related tests
- [ ] Tests follow Arrange-Act-Assert pattern
- [ ] All tests pass: `npm test`
- [ ] Coverage increased for target components
- [ ] No test warnings or errors
- [ ] Tests are readable and maintainable
- [ ] Edge cases covered (null, undefined, empty)

**Testing Instructions**:
```bash
# Run tests for specific file
npm test -- src/components/Modal/Modal.test.tsx

# Run with coverage for specific file
npm run test:coverage -- src/components/Modal

# Expected: Coverage for Modal.tsx increases from XX% to 90%+

# Check coverage in browser
open coverage/index.html
# Navigate to src/components/Modal/Modal.tsx
# Verify red/yellow sections are now green
```

**Common Test Scenarios**:
- Component renders without errors
- Component renders with different prop values
- Component handles missing/null/undefined props
- Component responds to user clicks
- Component responds to keyboard events
- Component displays loading state
- Component displays error state
- Component cleanup (unmount) works correctly

**Commit Message Template**:
```
test(components): add unit tests for under-tested components

- Add tests for Modal component (coverage: XX% → 92%)
- Add tests for PoemDates component (coverage: XX% → 90%)
- Test rendering, user interactions, and edge cases
- Follow Arrange-Act-Assert pattern
- Increase overall component coverage to XX%
```

**Estimated tokens**: ~20,000

---

### Task 3: Add Tests for Under-Tested Utilities

**Goal**: Write comprehensive unit tests for utility functions identified as having <100% coverage, ensuring all code paths and edge cases are tested.

**Files to Modify**:
- Existing test files in `src/utils/*.test.ts`
- New test files for untested utilities

**Prerequisites**:
- Task 1 complete (coverage baseline established)
- List of under-tested utility files identified
- Understanding of pure function testing

**Implementation Steps**:

1. **Identify under-tested utilities**:
   - Review coverage report for src/utils/**/*.ts files
   - Note specific uncovered lines and branches
   - Prioritize critical utility functions (date, sanitize, string)

2. **For each utility function**:
   - Understand function purpose and signature
   - Identify all code paths (if/else, switch, ternary)
   - List edge cases (null, undefined, empty, boundary values)
   - Write test case for each path and edge case

3. **Test pure functions thoroughly**:
   - Test with valid inputs (happy path)
   - Test with invalid inputs (error path)
   - Test with edge cases (null, undefined, empty string, zero, negative)
   - Test with boundary values (min, max, overflow)
   - Verify function doesn't mutate inputs

4. **Test error handling**:
   - Test functions that throw errors
   - Verify error messages are correct
   - Test validation logic
   - Test early returns

5. **Achieve 100% coverage for utils**:
   - Utils should be easiest to test (pure functions)
   - No excuse for <100% coverage on utility files
   - Every branch, every line must be tested
   - Re-run coverage until 100%

**Utility Testing Pattern**:
```typescript
// utils/string.test.ts
import { describe, it, expect } from 'vitest';
import { slugify, capitalize, truncate } from './string';

describe('string utils', () => {
  describe('slugify', () => {
    it('should convert string to slug', () => {
      expect(slugify('Hello World')).toBe('hello-world');
    });

    it('should handle special characters', () => {
      expect(slugify('Hello, World!')).toBe('hello-world');
    });

    it('should handle empty string', () => {
      expect(slugify('')).toBe('');
    });

    it('should handle null/undefined', () => {
      expect(slugify(null)).toBe('');
      expect(slugify(undefined)).toBe('');
    });

    it('should handle unicode characters', () => {
      expect(slugify('José García')).toBe('jose-garcia');
    });
  });

  describe('capitalize', () => {
    it('should capitalize first letter', () => {
      expect(capitalize('hello')).toBe('Hello');
    });

    it('should handle empty string', () => {
      expect(capitalize('')).toBe('');
    });

    it('should handle already capitalized', () => {
      expect(capitalize('Hello')).toBe('Hello');
    });
  });
});
```

**Edge Cases to Test**:
- `null` and `undefined` inputs
- Empty strings `""`
- Whitespace strings `"   "`
- Very long strings (performance)
- Special characters (unicode, emojis)
- Boundary values (0, -1, MAX_INT)
- Invalid types (if TypeScript allows `any`)

**Verification Checklist**:
- [ ] All utility functions have corresponding tests
- [ ] Every code branch is tested (if/else, switch)
- [ ] Edge cases covered (null, undefined, empty, boundary)
- [ ] Error cases tested (throws, validation)
- [ ] Utility files achieve 100% coverage
- [ ] All tests pass: `npm test`
- [ ] No warnings about uncovered lines

**Testing Instructions**:
```bash
# Run utils tests
npm test -- src/utils

# Run coverage for utils only
npm run test:coverage -- src/utils

# Check coverage
open coverage/index.html
# Navigate to src/utils/
# All files should show 100% coverage

# If not 100%, identify missing lines:
# - Look for red highlights in HTML report
# - Add test cases for those specific lines
# - Re-run coverage
```

**Achieving 100% Utils Coverage**:
```bash
# Run coverage and identify gaps
npm run test:coverage -- src/utils/date.test.ts

# Example gap: Line 42 not covered (error handling)
# Add test case:
it('should throw error for invalid date', () => {
  expect(() => formatDate(null)).toThrow('Invalid date');
});

# Re-run coverage
npm run test:coverage -- src/utils/date.test.ts
# Verify line 42 now covered
```

**Commit Message Template**:
```
test(utils): achieve 100% coverage for utility functions

- Add edge case tests for date utilities
- Test null/undefined handling in string utils
- Add error path tests for validation functions
- Cover all branches in performance utils
- Utils coverage: XX% → 100%
```

**Estimated tokens**: ~15,000

---

### Task 4: Add Tests for API Client and Hooks

**Goal**: Write tests for the API client and TanStack Query hooks, mocking HTTP requests and testing error handling, retry logic, and data transformation.

**Files to Modify**:
- `src/api/client.test.ts` - Enhance existing tests
- `src/hooks/queries/*.test.tsx` - Enhance existing hook tests
- New test files if needed

**Prerequisites**:
- Task 1 complete (coverage baseline established)
- Understanding of mocking in Vitest
- Familiarity with TanStack Query testing patterns

**Implementation Steps**:

1. **Test API client configuration**:
   - Test base URL configuration from environment
   - Test request interceptors (if any)
   - Test response interceptors (if any)
   - Test timeout configuration
   - Mock axios to avoid real HTTP calls

2. **Test API client methods**:
   - Test successful GET requests
   - Test failed requests (network errors)
   - Test 4xx error responses
   - Test 5xx error responses
   - Verify error messages are user-friendly

3. **Test TanStack Query hooks**:
   - Test successful data fetching
   - Test loading state
   - Test error state
   - Test retry logic (3 retries for 5xx, 0 for 4xx)
   - Test stale time and cache configuration
   - Mock query client for isolation

4. **Test hook error handling**:
   - Test user-friendly error messages
   - Test network error handling
   - Test 404 handling (don't retry)
   - Test 500 handling (retry with backoff)
   - Verify error message selector logic

5. **Test query invalidation and refetching**:
   - Test manual refetch
   - Test invalidation triggers
   - Test cache behavior (stale time, gc time)

**API Client Testing Pattern**:
```typescript
// api/client.test.ts
import { describe, it, expect, vi } from 'vitest';
import axios from 'axios';
import { cdnClient, apiClient } from './client';

vi.mock('axios');

describe('API clients', () => {
  describe('cdnClient', () => {
    it('should configure base URL from environment', () => {
      expect(cdnClient.defaults.baseURL).toBe(
        import.meta.env.VITE_CDN_BASE_URL
      );
    });

    it('should make GET request successfully', async () => {
      const mockData = { title: 'Test Poem' };
      vi.mocked(axios.create).mockReturnValueOnce({
        get: vi.fn().mockResolvedValue({ data: mockData }),
      } as any);

      const response = await cdnClient.get('/test');
      expect(response.data).toEqual(mockData);
    });
  });
});
```

**Hook Testing Pattern**:
```typescript
// hooks/queries/usePoemQuery.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { usePoemQuery } from './usePoemQuery';

describe('usePoemQuery', () => {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  it('should fetch poem successfully', async () => {
    const { result } = renderHook(() => usePoemQuery('20240101'), {
      wrapper,
    });

    await waitFor(() => expect(result.current.isSuccess).toBe(true));
    expect(result.current.data).toBeDefined();
  });

  it('should handle 404 error without retry', async () => {
    // Mock API to return 404
    // Verify retry count is 0
  });

  it('should retry on 500 error', async () => {
    // Mock API to return 500
    // Verify retry count is 3
    // Verify exponential backoff
  });
});
```

**Mocking Patterns**:
```typescript
// Mock axios
vi.mock('axios', () => ({
  default: {
    create: vi.fn(() => ({
      get: vi.fn(),
      post: vi.fn(),
      interceptors: {
        request: { use: vi.fn() },
        response: { use: vi.fn() },
      },
    })),
  },
}));

// Mock environment variables
vi.stubEnv('VITE_API_BASE_URL', 'https://test-api.com');
vi.stubEnv('VITE_CDN_BASE_URL', 'https://test-cdn.com');
```

**Verification Checklist**:
- [ ] API client tests cover all HTTP methods used
- [ ] API client tests cover error scenarios
- [ ] Hook tests cover loading, success, error states
- [ ] Hook tests verify retry logic
- [ ] Hook tests verify error message transformation
- [ ] All mocks are properly isolated
- [ ] Tests don't make real HTTP requests
- [ ] Coverage increased for API layer
- [ ] All tests pass consistently

**Testing Instructions**:
```bash
# Run API tests
npm test -- src/api

# Run hook tests
npm test -- src/hooks/queries

# Verify no real HTTP calls
# If tests make real HTTP, they'll fail without network
# Or be slow (>1s per test)

# Check coverage
npm run test:coverage -- src/api src/hooks
# Target: 85%+ for API, 90%+ for hooks
```

**Commit Message Template**:
```
test(api): add comprehensive API client and hooks tests

- Mock axios to prevent real HTTP calls
- Test error handling and retry logic
- Test TanStack Query hooks with query client wrapper
- Verify user-friendly error messages
- API layer coverage: XX% → 87%
```

**Estimated tokens**: ~12,000

---

### Task 5: Add Tests for Zustand Store Slices

**Goal**: Write comprehensive tests for Zustand store slices, testing state updates, action creators, and slice composition.

**Files to Modify**:
- `src/store/slices/*.test.ts` - Enhance existing tests
- `src/store/useAppStore.test.ts` - Test slice composition

**Prerequisites**:
- Task 1 complete (coverage baseline established)
- Understanding of Zustand testing patterns
- Existing store slice tests as reference

**Implementation Steps**:

1. **Test each store slice in isolation**:
   - Test initial state is correct
   - Test each action updates state correctly
   - Test state transitions are immutable
   - Test computed values (if any)

2. **Test audioSlice**:
   - Test setAudioData updates mp3Url and transcript
   - Test setAudioData revokes old blob URLs
   - Test togglePlayback toggles isPlaying
   - Test setCurrentTime clamps to >= 0
   - Test cleanup revokes blob URLs and resets state

3. **Test contentSlice**:
   - Test setCurrentDate updates state
   - Test setPoem updates poem data
   - Test setAuthor updates author data
   - Test setNotes updates notes

4. **Test searchSlice**:
   - Test setSearchTerm updates state
   - Test setResults updates search results
   - Test setIsSearching toggles search state
   - Test clearSearch resets to initial state

5. **Test store composition**:
   - Test combined store has all slices
   - Test actions from different slices don't interfere
   - Test selectors work correctly
   - Test shallow equality for performance

**Store Testing Pattern**:
```typescript
// store/slices/audioSlice.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { create } from 'zustand';
import { createAudioSlice } from './audioSlice';
import type { AudioSlice } from '../types';

describe('audioSlice', () => {
  let store: ReturnType<typeof create<AudioSlice>>;

  beforeEach(() => {
    store = create<AudioSlice>()(createAudioSlice);
  });

  describe('initial state', () => {
    it('should have correct initial values', () => {
      const state = store.getState();
      expect(state.mp3Url).toBeUndefined();
      expect(state.transcript).toBeUndefined();
      expect(state.isPlaying).toBe(false);
      expect(state.currentTime).toBe(0);
    });
  });

  describe('setAudioData', () => {
    it('should update mp3Url and transcript', () => {
      const { setAudioData } = store.getState();

      setAudioData({
        mp3Url: 'https://example.com/audio.mp3',
        transcript: 'Test transcript',
      });

      const state = store.getState();
      expect(state.mp3Url).toBe('https://example.com/audio.mp3');
      expect(state.transcript).toBe('Test transcript');
    });

    it('should handle partial updates', () => {
      const { setAudioData } = store.getState();

      setAudioData({ mp3Url: 'https://example.com/audio.mp3' });
      expect(store.getState().transcript).toBeUndefined();

      setAudioData({ transcript: 'Test' });
      expect(store.getState().mp3Url).toBe('https://example.com/audio.mp3');
      expect(store.getState().transcript).toBe('Test');
    });

    it('should revoke old blob URLs', () => {
      const { setAudioData } = store.getState();
      const revokeObjectURL = vi.spyOn(URL, 'revokeObjectURL');

      setAudioData({ mp3Url: 'blob:http://localhost/123' });
      setAudioData({ mp3Url: 'https://example.com/new.mp3' });

      expect(revokeObjectURL).toHaveBeenCalledWith('blob:http://localhost/123');
    });
  });

  describe('togglePlayback', () => {
    it('should toggle isPlaying state', () => {
      const { togglePlayback } = store.getState();

      expect(store.getState().isPlaying).toBe(false);
      togglePlayback();
      expect(store.getState().isPlaying).toBe(true);
      togglePlayback();
      expect(store.getState().isPlaying).toBe(false);
    });
  });

  describe('setCurrentTime', () => {
    it('should update current time', () => {
      const { setCurrentTime } = store.getState();

      setCurrentTime(42.5);
      expect(store.getState().currentTime).toBe(42.5);
    });

    it('should clamp negative values to 0', () => {
      const { setCurrentTime } = store.getState();

      setCurrentTime(-10);
      expect(store.getState().currentTime).toBe(0);
    });
  });

  describe('cleanup', () => {
    it('should reset all state', () => {
      const { setAudioData, setCurrentTime, togglePlayback, cleanup } =
        store.getState();

      setAudioData({ mp3Url: 'test.mp3', transcript: 'test' });
      setCurrentTime(100);
      togglePlayback();

      cleanup();

      const state = store.getState();
      expect(state.mp3Url).toBeUndefined();
      expect(state.transcript).toBeUndefined();
      expect(state.isPlaying).toBe(false);
      expect(state.currentTime).toBe(0);
    });

    it('should revoke blob URLs on cleanup', () => {
      const { setAudioData, cleanup } = store.getState();
      const revokeObjectURL = vi.spyOn(URL, 'revokeObjectURL');

      setAudioData({ mp3Url: 'blob:http://localhost/123' });
      cleanup();

      expect(revokeObjectURL).toHaveBeenCalledWith('blob:http://localhost/123');
    });
  });
});
```

**Testing Store Composition**:
```typescript
// store/useAppStore.test.ts
import { describe, it, expect } from 'vitest';
import { useAppStore } from './useAppStore';

describe('useAppStore', () => {
  it('should combine all slices', () => {
    const state = useAppStore.getState();

    // Audio slice
    expect(state.mp3Url).toBeDefined();
    expect(state.setAudioData).toBeTypeOf('function');

    // Content slice
    expect(state.currentDate).toBeDefined();
    expect(state.setPoem).toBeTypeOf('function');

    // Search slice
    expect(state.searchTerm).toBeDefined();
    expect(state.setSearchTerm).toBeTypeOf('function');
  });

  it('should not have slice actions interfere', () => {
    const { setAudioData, setSearchTerm } = useAppStore.getState();

    setAudioData({ mp3Url: 'test.mp3' });
    setSearchTerm('test search');

    const state = useAppStore.getState();
    expect(state.mp3Url).toBe('test.mp3');
    expect(state.searchTerm).toBe('test search');
  });
});
```

**Verification Checklist**:
- [ ] All store slices have comprehensive tests
- [ ] Initial state tested for each slice
- [ ] All actions tested with valid inputs
- [ ] Edge cases tested (null, undefined, boundary values)
- [ ] State immutability verified (no mutation)
- [ ] Blob URL cleanup tested (memory leak prevention)
- [ ] Store composition tested
- [ ] Coverage: 100% for store slices
- [ ] All tests pass consistently

**Testing Instructions**:
```bash
# Run store tests
npm test -- src/store

# Run with coverage
npm run test:coverage -- src/store

# Target: 100% coverage (store should be easiest to test)

# Check coverage
open coverage/index.html
# Navigate to src/store/slices/
# All files should show 100% coverage
```

**Commit Message Template**:
```
test(store): achieve 100% coverage for Zustand store

- Add comprehensive tests for audioSlice
- Add comprehensive tests for contentSlice
- Add comprehensive tests for searchSlice
- Test store composition and slice interaction
- Verify blob URL cleanup prevents memory leaks
- Store coverage: XX% → 100%
```

**Estimated tokens**: ~10,000

---

### Task 6: Generate Final Coverage Report and Document Improvements

**Goal**: Generate updated coverage report showing improvements, document what was achieved, and identify any remaining gaps for future work.

**Files to Create/Modify**:
- `docs/coverage-final.md` - Final coverage metrics
- `docs/testing-improvements.md` - Summary of testing work
- Update root `README.md` with coverage badge/metrics

**Prerequisites**:
- Tasks 1-5 complete (all tests written)
- All new tests passing
- No regressions in existing tests

**Implementation Steps**:

1. **Run final coverage analysis**:
   - Execute `npm run test:coverage`
   - Generate fresh HTML report
   - Note final coverage percentages
   - Compare to baseline from Task 1

2. **Document improvements**:
   - Calculate delta (final - baseline)
   - List files that improved from <70% to >85%
   - Identify files that reached 100% coverage
   - Note categories that met targets

3. **Identify remaining gaps** (if any):
   - Files still below 85% coverage
   - Uncovered edge cases
   - Integration test gaps
   - E2E test gaps

4. **Create coverage summary document**:
   - Side-by-side baseline vs. final metrics
   - List of files improved
   - Testing patterns established
   - Recommendations for future testing

5. **Update README** (optional):
   - Add coverage badge (if using CI/CD)
   - Add coverage metrics to features section
   - Link to coverage documentation
   - Note testing best practices

**Final Coverage Documentation Template**:
```markdown
# Test Coverage Improvements

**Date**: [Current date]
**Branch**: claude/design-new-feature-01SJt8Xs8ZfG9foLfshCCGsK

## Summary

Improved test coverage from **XX.XX%** to **YY.YY%** through systematic analysis and targeted test creation.

## Metrics Comparison

| Metric     | Baseline | Final   | Delta   |
|------------|----------|---------|---------|
| Statements | XX.XX%   | YY.YY%  | +ZZ.ZZ% |
| Branches   | XX.XX%   | YY.YY%  | +ZZ.ZZ% |
| Functions  | XX.XX%   | YY.YY%  | +ZZ.ZZ% |
| Lines      | XX.XX%   | YY.YY%  | +ZZ.ZZ% |

## Coverage by Category

| Category   | Baseline | Final   | Target | Status |
|------------|----------|---------|--------|--------|
| Components | XX.XX%   | YY.YY%  | 90%    | ✅ Met  |
| Hooks      | XX.XX%   | YY.YY%  | 95%    | ✅ Met  |
| Store      | XX.XX%   | 100%    | 100%   | ✅ Met  |
| Utils      | XX.XX%   | 100%    | 100%   | ✅ Met  |
| API        | XX.XX%   | YY.YY%  | 85%    | ✅ Met  |

## Files Improved

### Reached 100% Coverage
- `src/store/slices/audioSlice.ts` (XX% → 100%)
- `src/utils/date.ts` (XX% → 100%)

### Significantly Improved (>20% gain)
- `src/components/Modal/Modal.tsx` (XX% → YY%)
- `src/api/client.ts` (XX% → YY%)

## Testing Patterns Established

- Comprehensive component testing with Testing Library
- Pure function testing with edge cases
- Store testing with isolated slices
- API testing with mocked HTTP clients
- Hook testing with QueryClient wrapper

## Remaining Gaps

| File | Coverage | Reason | Recommendation |
|------|----------|--------|----------------|
| `src/App.tsx` | XX% | Large file, complex logic | Split into smaller components |
| `src/components/Particles/Particles.tsx` | XX% | Third-party library integration | Integration test instead |

## Recommendations

1. **Maintain 85%+ coverage** - Add tests for new features
2. **Test-driven development** - Write tests before implementation
3. **Coverage enforcement** - Add to CI/CD pipeline
4. **Integration tests** - Focus on data flow between layers
```

**Verification Checklist**:
- [ ] Final coverage report generated
- [ ] Coverage improvement documented
- [ ] Baseline vs. final comparison created
- [ ] Files improved listed with percentages
- [ ] Remaining gaps identified
- [ ] Recommendations for future work documented
- [ ] README updated (if applicable)
- [ ] Overall coverage meets 85%+ target

**Testing Instructions**:
```bash
# Generate final coverage
npm run test:coverage

# Compare to baseline
# Baseline: docs/coverage-baseline.md
# Final: docs/coverage-final.md

# Verify improvement
# Should see significant increase in all metrics

# Open HTML report
open coverage/index.html
# Visually verify most files are green
```

**Commit Message Template**:
```
docs(coverage): document test coverage improvements

- Generate final coverage report (XX% → YY%)
- Document files improved and testing patterns
- Identify remaining gaps for future work
- Add coverage metrics to README
- Create comprehensive testing improvement summary
```

**Estimated tokens**: ~6,000

---

## Phase Verification

### Complete Phase Checklist

Before proceeding to Phase 3, verify all items below:

**Coverage Analysis**:
- [ ] Baseline coverage report generated
- [ ] Under-tested files identified
- [ ] Prioritized testing list created
- [ ] docs/coverage-baseline.md exists

**Component Tests**:
- [ ] Tests added for all under-tested components
- [ ] Component coverage improved to 90%+
- [ ] Edge cases and error states tested
- [ ] User interactions tested

**Utility Tests**:
- [ ] All utility functions have tests
- [ ] Utility coverage reaches 100%
- [ ] Edge cases covered (null, undefined, empty, boundary)
- [ ] Error handling tested

**API Tests**:
- [ ] API client tests comprehensive
- [ ] HTTP mocking implemented correctly
- [ ] Hook tests cover loading, success, error states
- [ ] Retry logic tested
- [ ] API coverage improved to 85%+

**Store Tests**:
- [ ] All store slices tested comprehensively
- [ ] Store composition tested
- [ ] State immutability verified
- [ ] Store coverage reaches 100%

**Documentation**:
- [ ] Final coverage report generated
- [ ] Coverage improvements documented
- [ ] Testing patterns documented
- [ ] Remaining gaps identified

**Overall Metrics**:
- [ ] Overall coverage >= 85%
- [ ] Component coverage >= 90%
- [ ] Utils coverage = 100%
- [ ] Store coverage = 100%
- [ ] No test regressions

**Git State**:
- [ ] All changes committed
- [ ] Commit messages follow convention
- [ ] On feature branch
- [ ] Clean working directory

### Integration Testing

Verify test suite health:

```bash
# Run all tests
npm test

# Should see:
# ✓ XX test files passing
# ✓ YYY total test cases passing
# ✗ 0 failures

# Run E2E tests
npm run test:e2e

# Should see:
# ✓ 66 test cases passing
# ✗ 0 failures

# Generate final coverage
npm run test:coverage

# Should see:
# Statements: >85%
# Branches: >85%
# Functions: >85%
# Lines: >85%
```

### Success Metrics

Confirm these measurable outcomes:

- [ ] Overall coverage increased by 10%+ from baseline
- [ ] Component coverage >= 90%
- [ ] Utils coverage = 100%
- [ ] Store coverage = 100%
- [ ] Zero test failures
- [ ] Zero test warnings
- [ ] Test suite runs in <60 seconds
- [ ] Coverage report generation works

### Known Limitations

Document any limitations introduced in this phase:

1. **Large File Coverage**: `App.tsx` may still be below 90% due to size and complexity. Recommend splitting into smaller components in future refactoring.

2. **Third-Party Integration**: Components heavily using third-party libraries (Particles) may be difficult to test with unit tests. Consider integration tests instead.

3. **E2E Coverage**: E2E tests not counted in coverage metrics. True application coverage is higher than reported.

### Next Steps

Phase 2 is complete! Proceed to:
- **[Phase 3: Transcript Content Loading Fix](./Phase-3.md)** - Investigate and fix transcript data flow issue

---

## Summary

Phase 2 established a strong testing foundation through data-driven coverage analysis and systematic test creation. By running coverage reports, identifying gaps, and methodically writing tests for under-tested code, the project now has 85%+ test coverage with comprehensive tests for components, utilities, API clients, and state management.

**Key Achievements**:
- ✅ Increased overall coverage from ~75% to 85%+
- ✅ Achieved 100% coverage for utilities and store
- ✅ Achieved 90%+ coverage for components
- ✅ Established testing patterns and best practices
- ✅ Documented testing improvements

**Files Changed**:
- Created: Multiple `*.test.ts` and `*.test.tsx` files
- Created: `docs/coverage-baseline.md`, `docs/coverage-final.md`
- Created: `docs/testing-improvements.md`
- Modified: Existing test files to increase coverage
- Modified: Root `README.md` (optional coverage badge)

**Testing Infrastructure**:
- Unit tests: 31+ files (increased from 31)
- E2E tests: 6 files, 66 test cases (unchanged)
- Coverage tool: Vitest with v8 coverage
- Testing libraries: Vitest, Testing Library, Playwright
